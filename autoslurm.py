# -*- coding: utf-8 -*-
import typing
from   typing import *

min_py = (3, 8)

###
# Standard imports, starting with os and sys
###
import os
import sys
if sys.version_info < min_py:
    print(f"This program requires Python {min_py[0]}.{min_py[1]}, or higher.")
    sys.exit(os.EX_SOFTWARE)

__author__ = ['Dominic A. Sirianni']
__credits__ = ['Dominic A. Sirianni','Travis E. Greene']
__copyright__ = '(c) 2022 The Parish Lab'
__license__ = "BSD-3-Clause"
__date__ = "2022-07-06"
__email__ = "sirianni.dom@gmail.com"

###
# Other standard distro imports
###
import argparse
import contextlib
import getpass
mynetid = getpass.getuser()
import glob

###
# From hpclib
###
import linuxutils
from   sloppytree import SloppyTree
import slurmutils
from   urdecorators import trap

###
# imports and objects that are a part of this project
###
from scripts import slurm
verbose = False


cluster_data = slurmutils.parse_sinfo()
all_partitions = set(( k for k in cluster_data.keys() ))
condos = set(('bukach', 'diaz', 'erickson', 'johnson', 
                'parish', 'yang1', 'yang2', 'yangnolin'))
community_partitions_plenum = all_partitions - condos


programs = SloppyTree()
programs.qchem.versions = ('541', '532', '521') 
programs.gaussian.versions = ('G16B01', 'G16')


@trap
def autoslurm_main(args:argparse.Namespace) -> int:

    data = SloppyTree(dict(args))
    global cluster_data
    # Handles the 'inputs' argument, with a special case 
    # for the 'all' specification
    if 'all' in args.inputs: 
        if not (inputs := glob.glob("*.in")):
            raise Exception(""" 
`all` used for inputs, but there are no
input files (`*.in`) in this directory. Give me something to do!!
            """)
        data.inputs = inputs
    else:
        data.inputs = args.inputs
    data.email = args.mailuser

    # Iterate over passed inputs
    for inp in inputs:

        ## Job Name
        data.jobname = ( args.jobname 
            if args.jobname else 
            ".".join(inp.split('.')[:-1]) )

        ## CPUs
        data.cputotal = args.cputotal
        data.mpisockets = 2 if cputotal > 26 else 1
        data.ompthreads = cputotal // mpisockets

        data.mem = min(args.mem, cluster_data.partition.ram)
        
        # This is the slurm script that is generated by this Python script!
        # Edits to the following string will appear in all future qchem calculations.
        # Creates the .SLURM file 
        with open(f"{jobname}.slurm", 'w+') as f:
            s = slurm[data.exe]()
            # Writes the SLURM string to the file
            f.write(s)

        # Prints out the SLURM file to terminal if --dryrun was specified
        if args.dryrun:
            print(s)
            return os.EX_OK

        # Runs the calculation otherwise
        else:
            return dorunrun(f"sbatch {jobname}.slurm")

if __name__ == "__main__":

    from autoslurmhelp import helptext

    parser = argparse.ArgumentParser(description=helptext.description)
    parser.add_argument('inputs', nargs='+', type=list, help=helptext.inputs)

    # Input files specified by the user. The files must be in 
    # the current working directory

    # Allows control over what information you receive via E-Mail.
    parser.add_argument('-mt', '--mailtype', type=str, default="NONE", 
        choices=('NONE', 'BEGIN', 'END', 'FAIL', 'REQUEUE', 'ALL'), 
        help=helptext.mailtype)

    # Specifies the main user. This defaults to your own 
    # <urid>@richmond.edu email.
    parser.add_argument('-mu', '--mailuser', type=str, default=mynetid, 
        help=helptext.mailuser)

    # Jobname specification, default automatically assigns to 
    # the name of the file. I do not recommend changing this 
    # default as you may overwrite data!
    parser.add_argument('-j', '--jobname', default=None, type=str,
        help=helptext.jobname)

    parser.add_argument('-c', '--cputotal', default=24, type=int,
        choices=(range(50)), help=helptext.cputotal)

    parser.add_argument('-m', '--mem', default=380, type=int, help=helptext.mem)

    parser.add_argument('-q', '--partition', default='basic', type=str,
        choices=(cluster_data.partitions.keys()), help=helptext.partition)

    parser.add_argument('-x', '--exe', default='qchem', type=str,
        choices = slurm.keys(), help=helptext.exe)

    parser.add_argument('-v', '--version', default='', type=str, help=helptext.version)

    # Only generates the slurm script and does not submit 
    # the job to SLURM
    parser.add_argument('--dryrun', action='store_true', help=helptext.dryrun)
    parser.add_argument('-o', '--output', type=str, default="")
    parser.add_argument('--verbose', action='store_true',
        help="Be chatty about what is taking place")
    # Temporarily Removed Arguments
    #parser.add_argument('-t', '--ompthreads', default=12, 
    #      help="Number of threads for OpenMP parallelization")
    #parser.add_argument('-s', '--mpisockets', default=2, 
    #     help="Number of sockets for MPI parallelization")

    # Puts the arguments into a variable called args for further use

    myargs = parser.parse_args()
    verbose = myargs.verbose

    # Ensure the version of the program to be run makes some sense.
    if not myargs.version:
        myargs.version = max(myargs.exe.versions)
    elif myargs.version not in myargs.exe.versions:
        print(f"{myargs.exe} does not have a version {myargs.version}")
        sys.exit(os.EX_SOFTWARE)
    else:
        pass

    try:
        outfile = sys.stdout if not myargs.output else open(myargs.output, 'w')
        with contextlib.redirect_stdout(outfile):
            sys.exit(globals()[f"{os.path.basename(__file__)[:-3]}_main"](myargs))

    except Exception as e:
        print(f"Escaped or re-raised exception: {e}")

